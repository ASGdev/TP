---
title: 'DM : Pierre Feuile Ciseaux'
author: "Thibaut Vegreville - Titouan Larnicol"
date: "16 novembre 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Premi√®re Partie

Question 1)

Cas du joueur biais√© : 
1-On veut d√©terminer les gains moyens du joueur B en connaissant les probabilit√©s des choix de chaque joueurs. Alors on note P : pierre, F: Feuille et C: ciseaux .
La probabilit√© de gagner pour B est de :  1-P(B=P)*P(A=F)+P(B=C)*P(A=P)+P(B=F)*P(A=C)=0.3125
La probablit√© de perdre pour B est identique √† la probabilit√© de gagner, et on ne s'occupera pas de la probabilt√© du nul car il ne fait ni gagner ni perdre d'argent √† B et A.
D'o√π : E(B)=0.3125-0.3125=0. L'esp√©rance de B est de 0.

2-Lorsque les probabilit√©s de B changent on obtient la m√™me chose. 
E(B)=0.33-0.33=0

3-E(B)=1*P(B gagne)-1P(B perde)=1/0.5*x+0.25*y+0.25*(1-x-y)-(0.25*x+0.5*y+(1-x-y)*0.25)=0.5+0.25*(x-y)

4-Plus l'esp√©rance est √©lev√©, plus le joueur B est gagnant, on va donc chercher √† maximiser 0.25*(x-y).
Donc B √† tout int√©r√™t √† maximiser x et minimiser y(par exemple : x=1 et y=0)

5-

```{r}
#Papier = A, Caillou = B, Ciseaux = C
# no_m = non biaisÈ, m = biaisÈ

play=function(n){
  runif(n)
}
  
    
    
    
n=500
no_m_player = c()
m_player = c()

no_m_player=play(n)
m_player =play(n)
no_m_result = c()
m_result = c()
gain_no_m = 0
gain_m = 0

#transformation
for (i in 1:n){
    
      if(no_m_player[i]<=1/3){
        no_m_result = c(no_m_result,'A')
      }else if(no_m_player[i]<=2/3){
        no_m_result = c(no_m_result,'B')
      }else{
        no_m_result = c(no_m_result,'C')
      }
    
      if(m_player[i]<=1/4){
        m_result = c(m_result,'A')
      }else if(m_player[i]<=2/4){
        m_result = c(m_result,'B')
      }else{
        m_result = c(m_result,'C')
      }
}

#gain
for (i in 1:n){
  if(no_m_result[i]=='A' && m_result[i]=='B'){
    gain_no_m = gain_no_m +1
  }else if (no_m_result[i]=='A' && m_result[i]=='C'){
    gain_m = gain_m +1;
  }else if (no_m_result[i]=='B' && m_result[i]=='A'){
    gain_m = gain_m +1;
  }else if (no_m_result[i]=='B' && m_result[i]=='C'){
    gain_no_m = gain_no_m +1
  }else if (no_m_result[i]=='C' && m_result[i]=='A'){
    gain_no_m = gain_no_m +1
  }else if (no_m_result[i]=='C' && m_result[i]=='B'){
     gain_m = gain_m +1;
  }
}

```

##Partie 2

Question 2 - Apprentissage

1- On part sur un algorithme qui va calculer la fr√©quence des coups jou√©s par l'adversaire et notre coup suivant sera le coup qui gagne face au coup le plus jou√© par l'adversaire depuis le d√©but. 
Si au coup n, Pierre est le coup le plus jou√© depuis le d√©but par le joueur A, alors nous jouerons Feuille au prochain coup. A chaque passage nous re calculons les fr√©quences des coups adversaires.

```{r}

#Joue le counter statistique, et prÈfÈre par dÈfaut la stratÈgie pierre au premier tour
playOneTurn=function(liste){
    probA = sum(liste == 'A') 
    probB = sum(liste == 'B')
    probC = sum(liste == 'C')
    if(probA>probB && probA>probC){
      'C'
    }else if (probB>probA && probB>probC){
      'A'
    }else{
      'B'
    }
      
}

play=function(n){
  runif(n)
}

#Implementation basique : on joue le counter du coup le plus jouer par le joueur
n=500
listcoupjouer= c()
coup=c()
gain_algo = 0
gain_normal = 0

no_m_player=play(n)
gain_m = 0
gain_no_m=0

for (i in 1:n){
      #Jouer algo (calculer avant pour pas prendre en compte ce coup ci)
     coup = c(coup,playOneTurn(listcoupjouer))
      
      #Joueur alÈatoire
      if(no_m_player[i]<=1/3){
        listcoupjouer = c(listcoupjouer,'A')
      }else if(no_m_player[i]<=2/3){
        listcoupjouer = c(listcoupjouer,'B')
      }else{
        listcoupjouer = c(listcoupjouer,'C')
      }
      
      #gain
      if(no_m_result[i]=='A' && coup=='B'){
        gain_no_m = gain_no_m +1
      }else if (no_m_result[i]=='A' && coup[i]=='C'){
        gain_m = gain_m +1;
      }else if (no_m_result[i]=='B' && coup[i]=='A'){
        gain_m = gain_m +1;
      }else if (no_m_result[i]=='B' && coup[i]=='C'){
        gain_no_m = gain_no_m +1
      }else if (no_m_result[i]=='C' && coup[i]=='A'){
        gain_no_m = gain_no_m +1
      }else if (no_m_result[i]=='C' && coup[i]=='B'){
         gain_m = gain_m +1;
      }
}
gain_m
gain_no_m

#Statistiquement les rÈsultat sont les mÍme puisque l'algo dÈtecte 1/3 par pick puisque l'autre joueur est "alÈatoire". Il faudra plus probablement le faire jouer contre un biaisÈ pour voir un rÈsultat intÈrressant. Ci joint le test avec biaisÈ

#???NB : Les resultat sont Ètrange car le joueur algo perd systÈmatiquement contre le joueur biaisÈ (1/4 1/4 1/2), alors que ce devrais Ítre l'inverse (notre joueur aura tendance a jouer le counter de C donc A)

listcoupjouer= c()
coup=c()
gain_algo = 0
gain_normal = 0

no_m_player=play(n)
gain_m = 0
gain_no_m=0

for (i in 1:n){
      #Jouer algo (calculer avant pour pas prendre en compte ce coup ci)
      coup = c(coup,playOneTurn(listcoupjouer))
      
      #Joueur alÈatoire
      if(no_m_player[i]<=1/4){
        listcoupjouer = c(listcoupjouer,'A')
      }else if(no_m_player[i]<=2/4){
        listcoupjouer = c(listcoupjouer,'B')
      }else{
        listcoupjouer = c(listcoupjouer,'C')
      }
      
      #gain
      if(no_m_result[i]=='A' && coup[i]=='B'){
        gain_no_m = gain_no_m +1
      }else if (no_m_result[i]=='A' && coup[i]=='C'){
        gain_m = gain_m +1;
      }else if (no_m_result[i]=='B' && coup[i]=='A'){
        gain_m = gain_m +1;
      }else if (no_m_result[i]=='B' && coup[i]=='C'){
        gain_no_m = gain_no_m +1
      }else if (no_m_result[i]=='C' && coup[i]=='A'){
        gain_no_m = gain_no_m +1
      }else if (no_m_result[i]=='C' && coup[i]=='B'){
         gain_m = gain_m +1;
      }
}
gain_m
gain_no_m

```
