---
title: 'DM : Pierre Feuile Ciseaux'
author: "Thibaut Vegreville - Titouan Larnicol"
date: "16 novembre 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Première Partie

Question 1)

Cas du joueur biaisé : 
1-On veut déterminer les gains moyens du joueur B en connaissant les probabilités des choix de chaque joueurs. Alors on note P : pierre, F: Feuille et C: ciseaux .
La probabilité de gagner pour B est de :  1-P(B=P)*P(A=F)+P(B=C)*P(A=P)+P(B=F)*P(A=C)=0.3125
La probablité de perdre pour B est identique à la probabilité de gagner, et on ne s'occupera pas de la probabilté du nul car il ne fait ni gagner ni perdre d'argent à B et A.
D'où : E(B)=0.3125-0.3125=0. L'espérance de B est de 0.

2-Lorsque les probabilités de B changent on obtient la même chose. 
E(B)=0.33-0.33=0

3-E(B)=1*P(B gagne)-1P(B perde)=1/0.5*x+0.25*y+0.25*(1-x-y)-(0.25*x+0.5*y+(1-x-y)*0.25)=0.5+0.25*(x-y)

4-Plus l'espérance est élevé, plus le joueur B est gagnant, on va donc chercher à maximiser 0.25*(x-y).
Donc B à tout intérêt à maximiser x et minimiser y(par exemple : x=1 et y=0)

5-

```{r}
#Papier = A, Caillou = B, Ciseaux = C

play=function(n){
  runif(n)
}
  
    
    
    
n=500
no_m_player = c()
m_player = c()

no_m_player=play(n)
m_player =play(n)
no_m_result = c()
m_result = c()
gain_no_m = 0
gain_m = 0

#transformation
for (i in 1:n){
    
      if(no_m_player[i]<=1/3){
        no_m_result = c(no_m_result,'A')
      }else if(no_m_player[i]<=2/3){
        no_m_result = c(no_m_result,'B')
      }else{
        no_m_result = c(no_m_result,'C')
      }
    
      if(m_player[i]<=1/4){
        m_result = c(m_result,'A')
      }else if(m_player[i]<=2/4){
        m_result = c(m_result,'B')
      }else{
        m_result = c(m_result,'C')
      }
}

#gain
for (i in 1:n){
  if(no_m_result[i]=='A' && m_result[i]=='B'){
    gain_no_m = gain_no_m +1
  }else if (no_m_result[i]=='A' && m_result[i]=='C'){
    gain_m = gain_m +1;
  }else if (no_m_result[i]=='B' && m_result[i]=='A'){
    gain_m = gain_m +1;
  }else if (no_m_result[i]=='B' && m_result[i]=='C'){
    gain_no_m = gain_no_m +1
  }else if (no_m_result[i]=='C' && m_result[i]=='A'){
    gain_no_m = gain_no_m +1
  }else if (no_m_result[i]=='C' && m_result[i]=='B'){
     gain_m = gain_m +1;
  }
}

```

##Partie 2

Question 2 - Apprentissage

1- On part sur un algorithme qui va calculer la fréquence des coups joués par l'adversaire et notre coup suivant sera le coup qui gagne face au coup le plus joué par l'adversaire depuis le début. 
Si au coup n, Pierre est le coup le plus joué depuis le début par le joueur A, alors nous jouerons Feuille au prochain coup. A chaque passage nous re calculons les fréquences des coups adversaires.

```{r}

play=function(n){
  runif(n)
}


#automate de Shannon sur les deux dernier ?tat
n_2_v = FALSE
n_2_S = NULL
n_1_v = FALSE
n_1_S = NULL


#Implementation basique : on joue le coup joué par le joueur adverse au tour précédent.
n=500
no_m_player=play(n)
m_player =play(n)
no_m_result = c()
m_result = c()
gain_no_m = 0
gain_m = 0



for (i in 1:n){
    
      if(no_m_player[i]<=1/3){
        no_m_result = c(no_m_result,'A')
      }else if(no_m_player[i]<=2/3){
        no_m_result = c(no_m_result,'B')
      }else{
        no_m_result = c(no_m_result,'C')
      }
      if(m_player[i]<=1/4){
        m_result = c(m_result,'A')
      }else if(m_player[i]<=2/4){
        m_result = c(m_result,'B')
      }else{
        m_result = c(m_result,'C')
      }
}

#gain
for (i in 1:n){
  if(no_m_result[i]=='A' && m_result[i]=='B'){
    gain_no_m = gain_no_m +1
  }else if (no_m_result[i]=='A' && m_result[i]=='C'){
    gain_m = gain_m +1;
  }else if (no_m_result[i]=='B' && m_result[i]=='A'){
    gain_m = gain_m +1;
  }else if (no_m_result[i]=='B' && m_result[i]=='C'){
    gain_no_m = gain_no_m +1
  }else if (no_m_result[i]=='C' && m_result[i]=='A'){
    gain_no_m = gain_no_m +1
  }else if (no_m_result[i]=='C' && m_result[i]=='B'){
     gain_m = gain_m +1;
  }
  if(i!=n){
  m_result[i+1]=no_m_result[i]
  }
}

```
